from agent import *from models.products import *def run(context, session):    session.sessionbreakers = [SessionBreak(max_requests=3000)]    session.queue(Request("https://www.lbtechreviews.com/test", use='curl', force_charset='utf-8', max_age=0), process_revlist, dict())def process_revlist(data, context, session):    if not data.content:        return    revs = data.xpath('//div[contains(@class, "facetwp-template")]/a')    for rev in revs:        name = rev.xpath('following-sibling::div[1]//div/span[@class="prodtitle"]/text()').string()        url = rev.xpath("@href").string()        title = rev.xpath('following-sibling::div[1]/div/span[not(@class)]/text()').string(multiple=True)        summary = rev.xpath('following-sibling::div[1]//div/p/span/text()').string()        if 'the best' not in name.lower() and '%global_category%' not in url:            # All mini-revs has the full review            session.queue(Request(url, use='curl', force_charset='utf-8', max_age=0), process_review, dict(name=name, url=url, title=title, summary=summary))    next_url = data.xpath('//link[@rel="next"]/@href').string()    if next_url:        session.queue(Request(next_url, use='curl', force_charset='utf-8', max_age=0), process_revlist, dict())def process_review(data, context, session):    if not data.content:        return    if not data.xpath('''//script[contains(., '"@type": "Product"')]/text()''').string():        return    product = Product()    product.name = context['name'].encode('utf-8')    product.category = 'Tech'    url = data.xpath('//div[@class="testbox"]/a[regexp:test(., "official site", "i")]/@href').string()    product.url = url.split(':++')[-1].split(':+')[-1] if url else context['url']    product.ssid = context['url'].split('/')[-1]    prod_json = data.xpath('''//script[contains(., '"@type": "Product"')]/text()''').string()    review = Review()    review.title = context.get('title').encode('utf-8')    review.url = context['url']    review.type = 'pro'    review.ssid = product.ssid    date = data.xpath('//div[@class="published"]/text()').string()    if date:        review.date = date.split()[1]    author = data.xpath('//span/a[@itemprop="author"]').first()    if author:        author_name = author.xpath('text()').string()        author_url = author.xpath('@href').string()  # url with all revs by author        author_mail = data.xpath('//span[contains(@href, "mailto")]/@href').string()        if author_name and author_mail:            author_mail = author_mail.split('mailto:')[-1]            review.authors.append(Person(name=author_name, ssid=author_name, email=author_mail))        elif author_name:            review.authors.append(Person(name=author_name, ssid=author_name))    grade_overall = prod_json.split('"ratingValue": "')[-1].split('"')[0]    if grade_overall and grade_overall.isdigit():        review.grades.append(Grade(type='overall', value=float(grade_overall), best=6.0))    pros = data.xpath('//span[i[contains(@class, "advikonplus")]]/span/text()').string()    if pros:        review.add_property(type='pros', value=pros.strip())    cons = data.xpath('//span[i[contains(@class, "advikonminus")]]/span/text()').string()    if cons:        review.add_property(type='cons', value=cons.strip())    if context.get('summary'):        review.add_property(type='summary', value=context['summary'])    conclusion = data.xpath("//*[(self::h3 or self::h4) and regexp:test(., 'conclusion', 'i')]/following-sibling::p//text()").string(multiple=True)    if conclusion:        review.add_property(type='conclusion', value=conclusion)    excerpt = data.xpath('//div[@class="thecontent"]/p[not(preceding-sibling::*[(self::h3 or self::h4) and regexp:test(., "conclusion", "i")])]//text()').string(multiple=True)    if excerpt:        excerpt = excerpt.encode('utf-8')        review.add_property(type='excerpt', value=excerpt)        product.reviews.append(review)        session.emit(product)