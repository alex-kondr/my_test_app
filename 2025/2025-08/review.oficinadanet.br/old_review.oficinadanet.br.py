import stringfrom agent import *from models.products import *import redebug = Truedef run(context, session):   session.browser.agent = "Mozilla/5.0 (Macintosh; Intel Mac OS X 10.9; rv:26.0) Gecko/20100101 Firefox/26.0"   session.queue(Request('http://www.oficinadanet.com.br/reviews'), process_revlist, dict())def process_revlist(data, context, session):    for rev in data.xpath('//ul[contains(@class,"wifl lsn")]//li[a[regexp:test(@href,"(analise|review)")]]'):        url = rev.xpath("a//@href").string()        title = rev.xpath('descendant::node()[regexp:test(name(),"h\d")][contains(@class,"tit")]/text()').string(multiple=True)        if url and title:            name = re_search_once(u'^(.*) –', title)            if not(name):                name = title            if name:                name = name.replace('Review ', '')                session.queue(Request(url), process_review, dict(context, url=url, title=title, name=name))    next = data.xpath("//a[@class='nextpostslink']/@href").string()    if next:        session.queue(Request(next), process_revlist, dict(context))def process_review(data, context, session):    product = Product()    product.name = context['name']    product.url = context['url']    product.ssid = product.name    # Category    category = data.xpath('//a[contains(@href,"editoria")]//text()').join(' | ')    if category:        product.category = category    else:        product.category = 'unknown'    review = Review()    review.title = context['title']    review.url = context['url']    review.ssid = re_search_once('post\/(\d+)', review.url)    review.type = 'pro'    date = data.xpath('//div[contains(@class,"info")]//time//@datetime').string()    if date:        review.date = date[:-8]    author = data.xpath('//div[contains(@class,"info")]//a[@class="author"]').first()    if author:        name = author.xpath("text()").string(multiple=True)        url = author.xpath("@href").string()        if url and name:            ssid = re_search_once('autor\/(\d+)', url)            review.authors.append(Person(name=name, ssid=ssid, profile_url=url))    excerpt = data.xpath('//div[@itemprop="articleBody"]//p//text()').string(multiple=True)    if excerpt:        review.add_property(type='excerpt', value=excerpt)    summary = data.xpath('//div//h2[contains(text(),"Veredito")]/../following-sibling::p[not(span)][not(@style)]//text()').string(multiple=True)    if summary:       review.add_property(type='summary', value=summary)    pros = data.xpath('//table//td[regexp:test(normalize-space(.),"^Prós")]//ul/li')    if pros:       for pro in pros:          line = pro.xpath("descendant::text()").string(multiple=True)          if line:             line = line.replace('› ','').replace(';','').replace('.','')             review.add_property(type='pros', value=line)    cons = data.xpath('//table//td[regexp:test(normalize-space(.),"^Contras")]//ul/li')    if cons:       for con in cons:          line = con.xpath("descendant::text()").string(multiple=True)          if line:             line = line.replace('› ','').replace(';','').replace('.','')             review.add_property(type='cons', value=line)    #value = data.xpath('//div[@class="notafinal"]//div[@class="nota_texto_conteudo"]//span//text()').string(multiple=True)    #if value:    #   value = value.replace(',', '.')    #   value = value.replace('º', '.')    #   review.grades.append(Grade(name='NOTA FINAL', type='overall', value=float(value), best=10.0))    for g in data.xpath('//div[@class="bg_rev_notas"]//table//tr/td[@class="rrel_tipo"]'):       title = g.xpath('descendant::text()').string()       value = g.xpath('../following-sibling::tr[1]//td[contains(@class,"rrel_notabarra ")]//@colspan').string()       if title and value:          print title, value          if ',' in value: value = value.replace(',', '.')          review.grades.append(Grade(name=title, value=float(value), best=10.0))    product.reviews.append(review)    if product.reviews and (summary or excerpt):        session.emit(product)