# -*- coding: utf8 -*-from agent import *from models.products import *import time, randomdef run(context, session):    session.sessionbreakers=[SessionBreak(max_requests=20000)]    session.queue(Request('http://www.techstage.de/test/', use="curl"), process_category, {})def process_category(data, context, session):    for link in data.xpath('//div[@class="gradient-overlay"]//a'):        url = link.xpath('@href').string()        name = link.xpath('@title').string()        if url and name:            bad_list = [' im Test:']            for item in bad_list:                if item in name:                    namex = name.split(item)[0]                    if len(namex) == 0:                        name = name.split(item)[1]                    else:                        name = namex                    break            bad_list2 = ['Test:','Hands-on:','im Test','Preview:','Review:']            for item in bad_list2:                if item in name:                    name = name.replace(item, '')            session.queue(Request(url, use="curl"), process_product, dict(context, url=url, name=name))    # Next page    next=data.xpath('//a[@title="Mehr laden"]//@href').string()    if next:        session.queue(Request(next, use="curl"), process_category, {})def process_product(data, context, session):    product=Product()    product.name=context['name']    product.url=context['url']    # SSID    ssid = data.xpath('//node()[@data-article-id]//@data-article-id').string()    if ssid:        product.ssid=ssid    else:        product.ssid=product.name + product.url    # Category    category = data.xpath('//div[contains(@class,"taxonomy-tag")]//a//text()').join('|')    if category:        product.category='mobile|' + category    else:        product.category='mobile'    product.manufacturer=''    review=Review()    review.product=product.name    review.url=product.url    review.type='pro'    review.ssid=product.ssid + ' review'    # Publish date    #if '"datePublished": "' in data.content:    pub_date = data.xpath('//meta[@property="article:published_time"]//@content').string()#data.content.split('"datePublished": "')[1].split('"')[0]    if pub_date:        if ' ' in pub_date: pub_date=pub_date.split(' ')[0]        review.date=pub_date    # Author    revAuthor = data.xpath('//span[@class="author-name"]//text()').string(multiple=True)    if revAuthor:        review.authors.append(Person(name=revAuthor, ssid=revAuthor))    # Grades    if '"ratingValue": "' in data.content:        overall = data.content.split('"ratingValue": "')[1].split('"')[0]        review.grades.append(Grade(name='Overall Rating', type='overall', value=overall, best=5))    # Summary    summary=data.xpath('//meta[@name="description"]//@content').string(multiple=True)    if summary:        if 'Permalink' in summary: summary = summary.split('Permalink')[0]        review.properties.append(ReviewProperty(type='summary',value=summary))    # Conclusion    conc_list = [    '//node()[regexp:test(name(),"h\d")][regexp:test(descendant::text(),"(Zusammenfassung|Fazit)")]//following::p//text()',    '//node()[@id="nav_fazit_8"]/following-sibling::p//text()']    for item in conc_list:        conclusion = data.xpath(item).string(multiple=True)        if conclusion:            if 'Permalink' in conclusion: conclusion = conclusion.split('Permalink')[0]            review.properties.append(ReviewProperty(type='conclusion', value=conclusion))            break    # Pros    for p in data.xpath('//div[@class="proscons proscons--pros"]//li'):        pros=p.xpath('descendant::text()').string(multiple=True)        if pros:            review.properties.append(ReviewProperty(type='pros',value=pros))    # Cons    for c in data.xpath('//div[@class="proscons proscons--cons"]//li'):        cons=c.xpath('descendant::text()').string(multiple=True)        if cons:            review.properties.append(ReviewProperty(type='cons',value=cons))    product.reviews.append(review)    if product.reviews and summary:        session.emit(product)    time.sleep(random.randint(10,20))