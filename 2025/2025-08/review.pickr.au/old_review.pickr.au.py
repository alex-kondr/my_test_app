#!/usr/bin/python# -*- coding: utf-8 -*-from agent import *from models.products import *debug = Truedef run(context, session):    session.sessionbreakers=[SessionBreak(max_requests=10000)]    session.queue(Request('https://www.pickr.com.au/reviews/'), process_productlist, {})def process_productlist(data, context, session):    for link in data.xpath('//node()[regexp:test(name(),"h\d")][@class="jeg_post_title"]//a'):        url=link.xpath('@href').string()        name=link.xpath('text()').string()        if url and name:#and not session.seen(url):            session.queue(Request(url),process_product,dict(context,url=url,name=name))    # Next page    next=data.xpath('//a[@rel="next"]//@href').string() or data.xpath('//link[@rel="next"]//@href').string()    if next:        session.queue(Request(next), process_productlist, dict(context))def process_product(data, context, session):    product=Product()    product.url=context['url']    product.category=data.xpath('//meta[@property="article:tag"]//@content').join('|') or 'unknown'    # Name    name = data.xpath('//meta[@property="og:title"]//@content').string()    if name:        bad_list2 = ['â€“ Pickr','Review:','','','']        for item in bad_list2:            if item in name:                name = name.replace(item, '')        product.name=name    else:        product.name=context['name']    # Ssid    ssid = data.xpath('//article[contains(@class,"post-")]//@class').string()    if ssid:        product.ssid = ssid.split('post-')[1].split(' ')[0]    else:        product.ssid = product.name + product.url    review=Review()    review.product=product.name    review.url=product.url    review.ssid=product.ssid + ' review'    review.type='pro'    # Publish date    pub_date=data.xpath('//meta[@property="article:published_time"]//@content').string()    if pub_date:        if 'T' in pub_date: pub_date=pub_date.split('T')[0]        review.date=pub_date    else:        review.date='unknown'    # Author    author=data.xpath('//div[@class="jeg_meta_author"]//a[contains(@href,"author")]//text()').string(multiple=True)    if author:        review.authors.append(Person(name=author, ssid=author))    else:        review.authors.append(Person(name='unknown', ssid='unknown'))    # Grades    overall=data.xpath('//div[@class="score__wrap lr-all-c"]//div[@class="score"]//text()').string()    if overall:        review.grades.append(Grade(name='Overall Rating', type='overall', value=overall, best=5))    for g in data.xpath('//div[@class="lets-review-block__crit"]'):        name =g.xpath('div[contains(@class,"lets-review-block__crit__title")]//text()').string()        value=g.xpath('@data-score').string()        if value and name:            value = int(value) / 20.            review.grades.append(Grade(name=name, value=value, best=5))    # Conclusion    conclusion = data.xpath('//node()[regexp:test(name(),"h\d")][regexp:test(descendant::text(),"(Final thoughts)")]/following-sibling::p[text()]//text()').string(multiple=True)    if conclusion:        review.properties.append(ReviewProperty(type='conclusion', value=conclusion))    # Excerpt    exce_list = [    '//div[@class="single-container"]//p[text()]//text()',    '//meta[@property="og:description"]//@content']    for item in exce_list:        excerpt=data.xpath(item).string(multiple=True)        if excerpt:            review.properties.append(ReviewProperty(type='excerpt',value=excerpt[:135]+'...'))            break    # Pros    for p in data.xpath('//div[@class="lets-review-block__procon lets-review-block__pro"]'):        pros=p.xpath('descendant::text()').string(multiple=True)        if pros:            review.properties.append(ReviewProperty(type='pros',value=pros))    # Cons    for c in data.xpath('//div[@class="lets-review-block__procon lets-review-block__con"]'):        cons=c.xpath('descendant::text()').string(multiple=True)        if cons:            review.properties.append(ReviewProperty(type='cons',value=cons))    product.reviews.append(review)    if product.reviews:        session.emit(product)