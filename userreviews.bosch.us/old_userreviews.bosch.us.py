#!/usr/bin/python# -*- coding: utf-8 -*-from agent import *from models.products import *import yamldef run(context, session):   session.sessionbreakers = [SessionBreak(max_requests=30000)]   session.queue(Request('https://www.boschtools.com/us/en/sitemap/'), process_frontpage, {})def process_frontpage(data, context, session):    for cat in data.xpath('//div[@class="link-column col-lg-3 col-md-4"]//node()[regexp:test(name(),"h\d")]'):        mcat = cat.xpath('text()').string()        if mcat and 'Finder' not in mcat:            for xcat in cat.xpath('following-sibling::a'):                url = xcat.xpath('@href').string()                category = xcat.xpath('descendant::text()').string(multiple=True)                if url and category:                    category = mcat + ' | ' + category                    session.queue(Request(url), process_category, dict(url=url, category=category))def process_category(data, context, session):    is_cat = data.xpath('//div[@class="tile"]//a[contains(@href,"-c/")]//@href').string()    if is_cat:        for cat in data.xpath('//div[@class="tile"]'):            url = cat.xpath('descendant::a[contains(@href,"-c/")]//@href').string()            category = cat.xpath('descendant::div[@class="product-categorie__text"]//text()').string(multiple=True)            if url and category:                category = context['category'] + ' | ' + category                session.queue(Request(url), process_category, dict(context, url=url, category=category))    else:        for prod in data.xpath('//div[@class="product-catalog__tile"]'):            url = prod.xpath('descendant::a[contains(@href,"-p/")]//@href').string()            name = prod.xpath('descendant::div[@class="product-info__text"]//text()').string()            sku = prod.xpath('descendant::div[@ps-sku]//@ps-sku').string()            sku_bv = prod.xpath('descendant::div[@ps-sku]//@data-ps-bv-sku').string()            if url and name and sku and sku_bv:                name = name + ' (' + sku + ')'                session.queue(Request(url), process_product, dict(context, name=name, url=url, sku=sku, sku_bv=sku_bv))def process_product(data, context, session):    product = Product()    product.name = context['name']    product.url = context['url']    product.ssid = context['sku_bv']    product.category = context['category']    product.manufacturer = 'Bosch'    code = context['sku_bv']    revurl = "http://api.bazaarvoice.com/data/batch.json?passkey=mjblnkm24y2ynloumt11jaemk&apiversion=5.5&displaycode=4502-en_us&filter_reviews.q0=contentlocale:eq:en_US&filter.q0=productid:eq:" + code + "&resource.q0=reviews&sort.q0=relevancy:a1&limit.q0=10"    session.do(Request(revurl), process_reviews, dict(product=product, revurl=revurl))    if product.reviews:        session.emit(product)def process_reviews(data, context, session):    product = context['product']    offset = context.get('offset', 10)    jstxt = data.content    revs = yaml.load(jstxt)    cnt = 0    for rev in revs['BatchedResults']['q0']['Results']:        cnt += 1        review = Review()        review.title = rev['Title']        review.ssid = rev['Id']        review.url = product.url        review.type = 'user'        if rev.get('IsSyndicated'):            continue        if rev.get('ProductId') and rev.get('ProductId').lower() != str(product.ssid).lower():            print 'Review is for another product, original: %s, this: %s' % (rev['ProductId'], str(product.ssid))            continue        datetxt = rev['SubmissionTime']        if datetxt:            review.date = re_search_once('(\d{4}-\d{2}-\d{2})', datetxt)        author = rev['UserNickname']        if not(author):            author = 'Anonymous'        if author:            authorssid = rev['AuthorId']            review.authors.append(Person(name=author, ssid=authorssid))        excerpt = rev['ReviewText']        if excerpt:            product.reviews.append(review)            review.properties.append(ReviewProperty(type='excerpt', value=excerpt))        procons = rev['TagDimensions']        if procons.has_key('Pro'):            pros = procons['Pro']['Values']            for pro in pros:                review.properties.append(ReviewProperty(type='pros', value=pro))        if procons.has_key('Con'):           cons = procons['Con']['Values']           for con in cons:               review.properties.append(ReviewProperty(type='cons', value=con))        score = rev['Rating']        if score:            review.grades.append(Grade(name='Rating', type='overall', value=score, best=5))        if context.get('getSubgrades'):            for g in rev.get('SecondaryRatings', []):                review.grades.append(Grade(name=g, type='overall', value=int(rev['SecondaryRatings'][g]['Value']), best=5))    if context.get('limit') and cnt >= context.get('limit'):        return    if cnt == 10:        revurl = context['revurl'] + '&offset.q0=%s'%(offset+10)        session.do(Request(revurl), process_reviews, dict(context, offset=offset+10))